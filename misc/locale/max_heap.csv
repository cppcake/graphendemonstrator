,en,de
MAX_HEAP_INS,"// Add the new data to the end of the array\ntree_array.push_back[b]([/b]data[b])[/b];\n\n// Move it up [b]([/b][b]if[/b] needed[b])[/b]\n[b]int[/b] index = tree_array.size[b]([/b][b])[/b] - 1;\n[b]while[/b] [b]([/b]index > 0 && tree_array[lb]index] > tree_array[lb]parent[b]([/b]index[b])[/b]][b])[/b] [b]{[/b]\n\tstd::swap[b]([/b]tree_array[lb]index], tree_array[lb]parent[b]([/b]index[b])[/b]][b])[/b];\n\tindex = parent[b]([/b]index[b])[/b];\n[b]}[/b]\n\n[b]return[/b]\n\n--------------------------------------------------------------------------------------------------------------\n# Helpermethod to calculate the index of the parent\n[b]func[/b] parent[b]([/b]index[b])[/b] -> [b]int[/b]:\n\t[b]return[/b] floor[b]([/b][b]([/b]index - 1[b])[/b] / 2[b])[/b]\n","// Füge das neue Datum am Ende des Array hinzu\ntree_array.push_back[b]([/b]data[b])[/b];\n\n// Tausche mit Elternknoten [b]([/b]falls notwendig[b])[/b]\n[b]int[/b] index = tree_array.size[b]([/b][b])[/b] - 1;\n[b]while[/b] [b]([/b]index > 0 && tree_array[lb]index] > tree_array[lb]parent[b]([/b]index[b])[/b]][b])[/b] [b]{[/b]\n\tstd::swap[b]([/b]tree_array[lb]index], tree_array[lb]parent[b]([/b]index[b])[/b]][b])[/b];\n\tindex = parent[b]([/b]index[b])[/b];\n[b]}[/b]\n\n[b]return[/b]\n\n--------------------------------------------------------------------------------------------------------------\n# Hilfsfunktion um den Index des Elternknotens auszurechnen\n[b]func[/b] parent[b]([/b]index[b])[/b] -> [b]int[/b]:\n\t[b]return[/b] floor[b]([/b][b]([/b]index - 1[b])[/b] / 2[b])[/b]\n"
MAX_HEAP_RM,"// Swap the root with the last element\nstd::swap[b]([/b]tree_array[lb]0], tree_array[lb]tree_array.size[b]([/b][b])[/b] - 1][b])[/b];\n\n// Remove the last element\ntree_array.pop_back[b]([/b][b])[/b];\n\n[b]int[/b] size = tree_array.size[b]([/b][b])[/b];\n[b]int[/b] i = 0;\n\n[b]while[/b] [b]([/b]i < size[b])[/b] [b]{[/b]\n    [b]int[/b] left = i * 2 + 1;\n    [b]int[/b] right = left + 1;\n    [b]int[/b] largest = i;\n\n    // Check [b]if[/b] left child is larger\n    [b]if[/b] [b]([/b]left < size && tree_array[lb]left].data > tree_array[lb]largest].data[b])[/b] [b]{[/b]\n        largest = left;\n    [b]}[/b]\n\n    // Check [b]if[/b] right child is larger\n    [b]if[/b] [b]([/b]right < size && tree_array[lb]right].data > tree_array[lb]largest].data[b])[/b] [b]{[/b]\n        largest = right;\n    [b]}[/b]\n\n    // If the current node is the largest, [b]break[/b] the loop\n    [b]if[/b] [b]([/b]largest == i[b])[/b] [b]{[/b]\n        [b]break[/b];\n    [b]}[/b]\n\n    // Swap the largest child with the current node\n    std::swap[b]([/b]tree_array[lb]largest], tree_array[lb]i][b])[/b];\n\n    // Move to the largest child\n    i = largest;\n\n[b]return[/b]\n","// Tausche die Wurzel mit dem letzten Element\nstd::swap[b]([/b]tree_array[lb]0], tree_array[lb]tree_array.size[b]([/b][b])[/b] - 1][b])[/b];\n\n// Entferne das letzte Element [b]([/b]die ehemalige Wurzel also[b])[/b]\ntree_array.pop_back[b]([/b][b])[/b];\n\n[b]int[/b] size = tree_array.size[b]([/b][b])[/b];\n[b]int[/b] i = 0;\n\n[b]while[/b] [b]([/b]i < size[b])[/b] [b]{[/b]\n    [b]int[/b] left = i * 2 + 1;\n    [b]int[/b] right = left + 1;\n    [b]int[/b] largest = i;\n\n    // Überprüfe ob linkes Kind größer\n    [b]if[/b] [b]([/b]left < size && tree_array[lb]left].data > tree_array[lb]largest].data[b])[/b] [b]{[/b]\n        largest = left;\n    [b]}[/b]\n\n    // Überprüfe ob rechtes Kind noch größer\n    [b]if[/b] [b]([/b]right < size && tree_array[lb]right].data > tree_array[lb]largest].data[b])[/b] [b]{[/b]\n        largest = right;\n    [b]}[/b]\n\n    // Abbrechen, falls Knoten bereits größer als beide Kinder ist\n    [b]if[/b] [b]([/b]largest == i[b])[/b] [b]{[/b]\n        [b]break[/b];\n    [b]}[/b]\n\n    // Tausche ansonsten mit dem größten Kind\n    std::swap[b]([/b]tree_array[lb]largest], tree_array[lb]i][b])[/b];\n\n    // Aktualisiere Index auf der neuen Position des Knoten\n    i = largest;\n\n[b]return[/b]\n"
