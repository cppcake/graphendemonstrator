,en,de
MAX_HEAP_INS,"// Add the new data to the end of the array\ntree_array.push_back(data);\n\n// Move it up (if needed)\nint index = tree_array.size() - 1;\nwhile (index > 0 && tree_array[lb]index] > tree_array[lb]parent(index)]) {\n\tstd::swap(tree_array[lb]index], tree_array[lb]parent(index)]);\n\tindex = parent(index);\n}\n\nreturn\n\n--------------------------------------------------------------------------------------------------------------\n# Helpermethod to calculate the index of the parent\nfunc parent(index) -> int:\n\treturn floor((index - 1) / 2)\n","// Füge das neue Datum am Ende des Array hinzu\ntree_array.push_back(data);\n\n// Tausche mit Elternknoten (falls notwendig)\nint index = tree_array.size() - 1;\nwhile (index > 0 && tree_array[lb]index] > tree_array[lb]parent(index)]) {\n\tstd::swap(tree_array[lb]index], tree_array[lb]parent(index)]);\n\tindex = parent(index);\n}\n\nreturn\n\n--------------------------------------------------------------------------------------------------------------\n# Hilfsfunktion um den Index des Elternknotens auszurechnen\nfunc parent(index) -> int:\n\treturn floor((index - 1) / 2)\n"
MAX_HEAP_RM,"// Swap the root with the last element\nstd::swap(tree_array[lb]0], tree_array[lb]tree_array.size() - 1]);\n\n// Remove the last element\ntree_array.pop_back();\n\nint size = tree_array.size();\nint i = 0;\n\nwhile (i < size) {\n    int left = i * 2 + 1;\n    int right = left + 1;\n    int largest = i;\n\n    // Check if left child is larger\n    if (left < size && tree_array[lb]left].data > tree_array[lb]largest].data) {\n        largest = left;\n    }\n\n    // Check if right child is larger\n    if (right < size && tree_array[lb]right].data > tree_array[lb]largest].data) {\n        largest = right;\n    }\n\n    // If the current node is the largest, break the loop\n    if (largest == i) {\n        break;\n    }\n\n    // Swap the largest child with the current node\n    std::swap(tree_array[lb]largest], tree_array[lb]i]);\n\n    // Move to the largest child\n    i = largest;\n\nreturn\n","// Tausche die Wurzel mit dem letzten Element\nstd::swap(tree_array[lb]0], tree_array[lb]tree_array.size() - 1]);\n\n// Entferne das letzte Element (die ehemalige Wurzel also)\ntree_array.pop_back();\n\nint size = tree_array.size();\nint i = 0;\n\nwhile (i < size) {\n    int left = i * 2 + 1;\n    int right = left + 1;\n    int largest = i;\n\n    // Überprüfe ob linkes Kind größer\n    if (left < size && tree_array[lb]left].data > tree_array[lb]largest].data) {\n        largest = left;\n    }\n\n    // Überprüfe ob rechtes Kind noch größer\n    if (right < size && tree_array[lb]right].data > tree_array[lb]largest].data) {\n        largest = right;\n    }\n\n    // Abbrechen, falls Knoten bereits größer als beide Kinder ist\n    if (largest == i) {\n        break;\n    }\n\n    // Tausche ansonsten mit dem größten Kind\n    std::swap(tree_array[lb]largest], tree_array[lb]i]);\n\n    // Aktualisiere Index auf der neuen Position des Knoten\n    i = largest;\n\nreturn\n"
