keys,en,de
INS_FRONT_DL,size += 1;\nDListNodeptr new_node_ptr = std::make_shared<DoublyLinkedListNode>[b]([/b]x[b])[/b];\n\n// Case 1: List is empty\n[b]if[/b][b]([/b]empty[b]([/b][b])[/b][b])[/b] [b]{[/b]\n    head = new_node_ptr;\n    tail = new_node_ptr;\n    [b]return[/b];\n    [b]}[/b]\n\n// Case 2: List is not empty\nnew_node_ptr->next = head;\nhead->prev = new_node_ptr;\nhead = new_node_ptr;\n[b]return[/b];\n,size += 1;\nDListNodeptr new_node_ptr = std::make_shared<DoublyLinkedListNode>[b]([/b]x[b])[/b];\n\n// Fall 1: Liste ist leer\n[b]if[/b][b]([/b]empty[b]([/b][b])[/b][b])[/b] [b]{[/b]\n    head = new_node_ptr;\n    tail = new_node_ptr;\n    [b]return[/b];\n    [b]}[/b]\n\n// Fall 2: Liste ist nicht leer\nnew_node_ptr->next = head;\nhead->prev = new_node_ptr;\nhead = new_node_ptr;\n[b]return[/b];\n
INS_AFTER_DL,size += 1;\nDListNodeptr new_node_ptr = std::make_shared<DoublyLinkedListNode>[b]([/b]x[b])[/b];\n\nnew_node_ptr->next = pred->next;\nnew_node_ptr->prev = pred;\npred->next = new_node_ptr;\n\n[b]if[/b][b]([/b]pred != tail[b])[/b][b]{[/b]\n    new_node_ptr->next->prev = new_node_ptr;\n    [b]return[/b];\n    [b]}[/b]\n\ntail = new_node_ptr;\n[b]return[/b];\n,size += 1;\nDListNodeptr new_node_ptr = std::make_shared<DoublyLinkedListNode>[b]([/b]x[b])[/b];\n\nnew_node_ptr->next = pred->next;\nnew_node_ptr->prev = pred;\npred->next = new_node_ptr;\n\n[b]if[/b][b]([/b]pred != tail[b])[/b][b]{[/b]\n    new_node_ptr->next->prev = new_node_ptr;\n    [b]return[/b];\n    [b]}[/b]\n\ntail = new_node_ptr;\n[b]return[/b];\n
RM_DL,size -= 1;\n\n// Case 1: Only one element in List\n[b]if[/b][b]([/b]head == tail && !empty[b]([/b][b])[/b][b])[/b][b]{[/b]\n    head.reset[b]([/b][b])[/b];\n    tail.reset[b]([/b][b])[/b];\n    [b]return[/b];\n    [b]}[/b]\n\n// Case 2: Removing first element\n[b]if[/b][b]([/b]to_remove_ptr == head[b])[/b][b]{[/b]\n    head = head->next;\n    head->prev.reset[b]([/b][b])[/b];\n    [b]return[/b];\n    [b]}[/b]\n\n// Case 3: Removing last element\n[b]if[/b][b]([/b]to_remove_ptr == tail[b])[/b][b]{[/b]\n    tail = tail->prev.lock[b]([/b][b])[/b];\n    tail->next.reset[b]([/b][b])[/b];\n    [b]return[/b];\n    [b]}[/b]\n\n// Case 4: Removing element between head [b]and[/b] tail\nto_remove_ptr->next->prev = to_remove_ptr->prev;\nto_remove_ptr->prev.lock[b]([/b][b])[/b]->next = to_remove_ptr->next;\n[b]return[/b];\n,size -= 1;\n\n// Fall 1: Nur ein Element in der Liste\n[b]if[/b][b]([/b]head == tail && !empty[b]([/b][b])[/b][b])[/b][b]{[/b]\n    head.reset[b]([/b][b])[/b];\n    tail.reset[b]([/b][b])[/b];\n    [b]return[/b];\n    [b]}[/b]\n\n// Fall 2: Das erste Element wird entfernt\n[b]if[/b][b]([/b]to_remove_ptr == head[b])[/b][b]{[/b]\n    head = head->next;\n    head->prev.reset[b]([/b][b])[/b];\n    [b]return[/b];\n    [b]}[/b]\n\n// Fall 3: Das letzte Element wird entfernt\n[b]if[/b][b]([/b]to_remove_ptr == tail[b])[/b][b]{[/b]\n    tail = tail->prev.lock[b]([/b][b])[/b];\n    tail->next.reset[b]([/b][b])[/b];\n    [b]return[/b];\n    [b]}[/b]\n\n// Fall 4: Element zwischen head und tail wird entfernt\nto_remove_ptr->next->prev = to_remove_ptr->prev;\nto_remove_ptr->prev.lock[b]([/b][b])[/b]->next = to_remove_ptr->next;\n[b]return[/b];\n
