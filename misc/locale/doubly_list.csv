keys,en,de
INS_FRONT_DL,size += 1;\nDListNodeptr new_node_ptr = std::make_shared<DoublyLinkedListNode>(x);\n\n// Case 1: List is empty\nif(empty()) {\n\thead = new_node_ptr;\n\ttail = new_node_ptr;\n\treturn\n}\n\n// Case 2: List is not empty:\nnew_node_ptr->next = head;\nhead->prev = new_node_ptr;\nhead = new_node_ptr;\nreturn;,size += 1;\nDListNodeptr new_node_ptr = std::make_shared<DoublyLinkedListNode>(x);\n\n// Case 1: List is empty\nif(empty()) {\n\thead = new_node_ptr;\n\ttail = new_node_ptr;\n\treturn\n}\n\n// Case 2: List is not empty:\nnew_node_ptr->next = head;\nhead->prev = new_node_ptr;\nhead = new_node_ptr;\nreturn;
INS_AFTER_DL,size += 1;\nDListNodeptr new_node_ptr = std::make_shared<DoublyLinkedListNode>(x);\nnew_node_ptr->next = pred->next;\nnew_node_ptr->prev = pred;\npred->next = new_node_ptr;\n\nif(pred != tail){\n\tnew_node_ptr->next->prev = new_node_ptr;\n\treturn;\n}\n\ntail = new_node_ptr;\nreturn;,size += 1;\nDListNodeptr new_node = std::make_shared<DoublyLinkedListNode>(x);\nnew_node->next = pred->next;\nnew_node->prev = pred;\n\nif(pred != tail)\n\tpred->next->prev = new_node;\n\npred->next = new_node;\nreturn;
RM_DL,size -= 1;\n// Case 1: Only one element in List\nif(head == tail && !empty()){\n\thead.reset();\n\ttail.reset();\n\treturn;\n}\n\n// Case 2: Removing first element\nif(to_remove_ptr == head){\n\thead = head->next;\n\thead->prev.reset();\n\treturn;\n}\n\n// Case 3: Removing last element\nif(to_remove_ptr == tail){\n\ttail = tail->prev.lock();\n\ttail->next.reset();\n\treturn;\n}\n\n// Case 4: Removing element between head and tail\nto_remove_ptr->next->prev = to_remove_ptr->prev;\nto_remove_ptr->prev.lock()->next = to_remove_ptr->next;\nreturn;,1.head = head->next
