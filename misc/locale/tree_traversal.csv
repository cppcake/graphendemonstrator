keys,en,de
INS_BST,"if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}","if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}"
,,
PREORDER,if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F\n\nappend start_ptr->data to sequence\ninsert inorder(start_ptr->left) behind F\ninsert inorder(start_ptr->right) behind F\n\nreturn F\n,if start_ptr == nullptr do\n\treturn\n\nErstelle leere Folge F\n\nFüge start_ptr->data am Ende von F ein\nFüge inorder(start_ptr->left) hinter F ein\nFüge inorder(start_ptr->right) hinter F ein\n\nreturn F\n
INORDER,if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F\n\ninsert inorder(start_ptr->left) behind F\nappend start_ptr->data to F\ninsert inorder(start_ptr->right) behind F\n\nreturn F\n,if start_ptr == nullptr do\n\treturn\n\nErstelle leere Folge F\n\nFüge inorder(start_ptr->left) hinter F ein\nFüge start_ptr->data am Ende von F ein\nFüge inorder(start_ptr->right) hinter F ein\n\nreturn F\n
POSTORDER,if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F\n\ninsert inorder(start_ptr->left) behind F\ninsert inorder(start_ptr->right) behind F\nappend start_ptr->data to sequence\n\nreturn F\n,if start_ptr == nullptr do\n\treturn\n\nErstelle leere Folge F\n\nFüge inorder(start_ptr->left) hinter F ein\nFüge inorder(start_ptr->right) hinter F ein\nFüge start_ptr->data am Ende von F ein\n\nreturn F\n
LEVELORDER,Create empty sequence F and empty queue Q\nQ.push(start_ptr)\n\nwhile Q is not empty do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n,Erstelle leere Folge F und leere Warteschlange Q\nQ.push(start_ptr)\n\nwhile Q nicht leer do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n
