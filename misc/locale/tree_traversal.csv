keys,en,de
INS_BST,"if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}","if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}"
,,
INORDER,"if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F, F_left, F_right\n\nF_left = inorder(start_ptr->left)\nF_right = inorder(start_ptr->right)\n\ninsert F_left behind F\nappend start_ptr->data to sequence\ninsert F_right behind F\n\nreturn F\n","if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F, F_left, F_right\n\nF_left = inorder(start_ptr->left)\nF_right = inorder(start_ptr->right)\n\ninsert F_left behind F\nappend start_ptr->data to sequence\ninsert F_right behind F\n\nreturn F\n"
LEVELORDER,Create empty sequence F and empty queue Q\nQ.push(start_ptr)\n\nwhile Q is not empty do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n,Create empty sequence F and empty queue Q\nQ.push(start_ptr)\n\nwhile Q is not empty do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n
