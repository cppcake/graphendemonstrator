keys,en,de
INS_BST,"if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}","if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}"
,,
INORDER,"if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F, F_left, F_right\n\nF_left = inorder(start_ptr->left)\nF_right = inorder(start_ptr->right)\n\ninsert F_left behind F\nappend start_ptr->data to sequence\ninsert F_right behind F\n\nreturn F\n","if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F, F_left, F_right\n\nF_left = inorder(start_ptr->left)\nF_right = inorder(start_ptr->right)\n\ninsert F_left behind F\nappend start_ptr->data to sequence\ninsert F_right behind F\n\nreturn F\n"
LEVELORDER,Create empty sequence F and empty queue Q\nQ.push(start_ptr)\n\nwhile Q is not empty do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n,Create empty sequence F and empty queue Q\nQ.push(start_ptr)\n\nwhile Q is not empty do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n
,,
,,
MAX_HEAP,"# Insert it!\ntree_array.push_back(data)\nsize += 1\n\n# Move it up! (if needed)\nindex = tree_array.size()\nwhile index > 0 and tree_array[index].data > tree_array[parent(index)].data do\n\tswap(tree_array[index], tree_array[parent(index)])\n\tindex = parent(index)\n\nreturn\n\n\n\n# Helpermethod to calculate the index of the parent\nfunc parent(index) -> int:\n\treturn floor((index - 1) / 2)\n","# Insert it!\ntree_array.push_back(data)\nsize += 1\n\n# Move it up! (if needed)\nindex = tree_array.size()\nwhile index > 0 and tree_array[index].data > tree_array[parent(index)].data do\n\tswap(tree_array[index], tree_array[parent(index)])\n\tindex = parent(index)\n\nreturn\n\n\n\n# Helpermethod to calculate the index of the parent\nfunc parent(index) -> int:\n\treturn floor((index - 1) / 2)\n"
