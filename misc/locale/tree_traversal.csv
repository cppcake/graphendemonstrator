keys,en,de
INS_BST,"if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}","if(root_ptr == nullptr){\n\troot_ptr = std::make_shared<TreeNode>(data);\n\treturn;\n}\n\nif(root_ptr->data > data){\n\tinsert(root_ptr->left_child_ptr, data);\n} else{\n\tinsert(root_ptr->right_child_ptr, data);\n}"
,,
INORDER,"if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F, F_left, F_right\n\nF_left = inorder(start_ptr->left)\nF_right = inorder(start_ptr->right)\n\ninsert F_left behind F\nappend start_ptr->data to sequence\ninsert F_right behind F\n\nreturn F\n","if start_ptr == nullptr do\n\treturn\n\nCreate empty sequence F, F_left, F_right\n\nF_left = inorder(start_ptr->left)\nF_right = inorder(start_ptr->right)\n\ninsert F_left behind F\nappend start_ptr->data to sequence\ninsert F_right behind F\n\nreturn F\n"
LEVELORDER,Create empty sequence F and empty queue Q\nQ.push(start_ptr)\n\nwhile Q is not empty do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n,Create empty sequence F and empty queue Q\nQ.push(start_ptr)\n\nwhile Q is not empty do\n\tLet current_ptr = Q.pop()\n\tif current_ptr != nullptr then\n\t\tF.push(current_ptr->data)\n\t\tQ.push_back(current_ptr->left)\n\t\tQ.push_back(current_ptr->right)\n\nreturn F\n
,,
,,
MAX_HEAP_INS,"// Add the new data to the end of the array\ntree_array.push_back(data);\n\n// Move it up (if needed)\nint index = tree_array.size() - 1;\nwhile (index > 0 && tree_array[lb]index] > tree_array[lb]parent(index)]) {\n\tstd::swap(tree_array[lb]index], tree_array[lb]parent(index)]);\n\tindex = parent(index);\n}\n\nreturn\n\n--------------------------------------------------------------------------------------------------------------\n# Helpermethod to calculate the index of the parent\nfunc parent(index) -> int:\n\treturn floor((index - 1) / 2)\n","// Add the new data to the end of the array\ntree_array.push_back(data);\n\n// Move it up (if needed)\nint index = tree_array.size() - 1;\nwhile (index > 0 && tree_array[lb]index] > tree_array[lb]parent(index)]) {\n\tstd::swap(tree_array[lb]index], tree_array[lb]parent(index)]);\n\tindex = parent(index);\n}\n\nreturn\n\n--------------------------------------------------------------------------------------------------------------\n# Helpermethod to calculate the index of the parent\nfunc parent(index) -> int:\n\treturn floor((index - 1) / 2)\n"
,,
MAX_HEAP_RM,"// Swap the root with the last element\nstd::swap(tree_array[lb]0], tree_array[lb]tree_array.size() - 1]);\n\n// Remove the last element\ntree_array.pop_back();\n\nint size = tree_array.size();\nint i = 0;\n\nwhile (i < size) {\n    int left = i * 2 + 1;\n    int right = left + 1;\n    int largest = i;\n\n    // Check if left child is larger\n    if (left < size && tree_array[lb]left].data > tree_array[lb]largest].data) {\n        largest = left;\n    }\n\n    // Check if right child is larger\n    if (right < size && tree_array[lb]right].data > tree_array[lb]largest].data) {\n        largest = right;\n    }\n\n    // If the current node is the largest, break the loop\n    if (largest == i) {\n        break;\n    }\n\n    // Swap the largest child with the current node\n    std::swap(tree_array[lb]largest], tree_array[lb]i]);\n\n    // Move to the largest child\n    i = largest;\n\nreturn\n","// Swap the root with the last element\nstd::swap(tree_array[lb]0], tree_array[lb]tree_array.size() - 1]);\n\n// Remove the last element\ntree_array.pop_back();\n\nint size = tree_array.size();\nint i = 0;\n\nwhile (i < size) {\n    int left = i * 2 + 1;\n    int right = left + 1;\n    int largest = i;\n\n    // Check if left child is larger\n    if (left < size && tree_array[lb]left].data > tree_array[lb]largest].data) {\n        largest = left;\n    }\n\n    // Check if right child is larger\n    if (right < size && tree_array[lb]right].data > tree_array[lb]largest].data) {\n        largest = right;\n    }\n\n    // If the current node is the largest, break the loop\n    if (largest == i) {\n        break;\n    }\n\n    // Swap the largest child with the current node\n    std::swap(tree_array[lb]largest], tree_array[lb]i]);\n\n    // Move to the largest child\n    i = largest;\n\nreturn\n"
