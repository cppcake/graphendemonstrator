// Tausche die Wurzel mit dem letzten Element\nstd::swap(tree_array[lb]0], tree_array[lb]tree_array.size() - 1]);\n\n// Entferne das letzte Element (die ehemalige Wurzel also)\ntree_array.pop_back();\n\nint size = tree_array.size();\nint i = 0;\n\nwhile (i < size) {\n    int left = i * 2 + 1;\n    int right = left + 1;\n    int largest = i;\n\n    // Überprüfe ob linkes Kind größer\n    if (left < size && tree_array[lb]left].data > tree_array[lb]largest].data) {\n        largest = left;\n    }\n\n    // Überprüfe ob rechtes Kind noch größer\n    if (right < size && tree_array[lb]right].data > tree_array[lb]largest].data) {\n        largest = right;\n    }\n\n    // Abbrechen, falls Knoten bereits größer als beide Kinder ist\n    if (largest == i) {\n        break;\n    }\n\n    // Tausche ansonsten mit dem größten Kind\n    std::swap(tree_array[lb]largest], tree_array[lb]i]);\n\n    // Aktualisiere Index auf der neuen Position des Knoten\n    i = largest;\n\nreturn\n