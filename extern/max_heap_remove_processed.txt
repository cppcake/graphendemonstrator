// Swap the root with the last element\nstd::swap(tree_array[lb]0], tree_array[lb]tree_array.size() - 1]);\n\n// Remove the last element\ntree_array.pop_back();\n\nint size = tree_array.size();\nint i = 0;\n\nwhile (i < size) {\n    int left = i * 2 + 1;\n    int right = left + 1;\n    int largest = i;\n\n    // Check if left child is larger\n    if (left < size && tree_array[lb]left].data > tree_array[lb]largest].data) {\n        largest = left;\n    }\n\n    // Check if right child is larger\n    if (right < size && tree_array[lb]right].data > tree_array[lb]largest].data) {\n        largest = right;\n    }\n\n    // If the current node is the largest, break the loop\n    if (largest == i) {\n        break;\n    }\n\n    // Swap the largest child with the current node\n    std::swap(tree_array[lb]largest], tree_array[lb]i]);\n\n    // Move to the largest child\n    i = largest;\n\nreturn\n